## OSI 7 Layer

**7 계층 : Application Layer(응용 계층)**

> 사용자 인터페이스의 역할을 담당하는 계층 ( 즉, 사용자가 이용하는 네트워크 응용프로그램)
>
> EX) Internet Explorer
>
> 사용자와 가장 가까운 프로토콜을 정의
>
> EX) HTTP(80), FTP(20,21), Telnet(23), SMTP(25), DNS(53), TFTP(69) 등



**6 계층 : Presentation Layer(표현 계층)**

> 전송하는 데이터의 Format(구성 방식)을 결정하는 계층
>
> 다양한 데이터 Format을 일관되게 상호 변환, 압축 및 암호화, 복호화 기능을 수행
>
> EX) ASCII, EBCDIC, CIF, JPEG, AVI, MPEG 등

 

**5 계층 : Session Layer(세션 계층)**

> 네트워크 상에서 통신을 할 경우 양쪽 host간 최초 연결이 되게 하고 통신 중 연결이 지속되도록 시켜주는 역할을 하는 계층.통신을 하는 두 host사이에 세션을 열고, 닫고, 관리하는 기능을 담당.
>
> 데이터 동기화와 네트워크 오류 이벤트 검사, 오류가 발생한 지점 이후의 데이터만 재전송 보장.
>
> 데이터 송수신 방식(Duplex), 반 이중 방식(Half Duplex), 전 이중 방식(Full Duplex)의 통신과 함께, 체크 포인팅과 유휴, 종료, 다시 시작 과정을 수행

**7 6 5계층을 통하여 data가 만들어 짐.**

===============================================================

 

**4 계층 : Transport Layer(전송 계층)**

> 정보를 분할하고, 상대편에 도달하기 전에 다시 합치는 과정을 담당하는 계층
>
> 4계층의 단위 : Segment
>
> 목적지 컴퓨터에서 발신지 컴퓨터 간의 통신에 있어 Error control(에러제어)와 Flow control(흐름 제어)를 담당.
>
> 전송 방식을 결정 ex) 포트번호나 TCP/UDP 등
>
> 4계층 프로토콜 : TCP, UDP
>
> TCP - 신뢰성, 연결지향성 프로토콜, Connection-ful(연결을 유지하며 전송하는 방식
>
> UDP - 비 신뢰성, 비 연결지향성 프로토콜, Connection-less(연결을 유지하지 않고 전송하는 방식, data손실을 신경쓰지 않음)

 

**3 계층 : Network Layer(네트워크 계층)**

> Logical address(IP)를 담당하고, 패킷의 이동경로를 결정하는 계층
>
> 3계층의 단위 : Packet
>
> 경로선택, 라우팅, 논리적인주소(IP)를 정의하는 계층
>
> Routing Protocol을 이용하여 최적경로를 선택
>
> 3계층 장비 : Router

 

**2 계층 : Data Link Layer(데이터링크 계층)**

> 물리적 계층을 통한 데이터 전송에 신뢰성을 제공
>
> 이러한 서비스를 위해 물리적 주소(MAC) 지정, 네트워크 토폴로지, 오류통지, 프레임의 순차적 전송, 흐름제어 등의 기능을 가짐.
>
> 직접 연결되어 있지 않은 네트워크에 대해서는 상위 계층에서 오류 제어를 담당.
>
> 두가지 하위 게층이 존재
>
> Logical Link contorl - 통신 장치간의 연결을 설정하고 관리하는 책임
>
> Media Access Control - 다중 장치가 같은 미디어 채널을 공유, 제어(Block ID + Device ID)
>
> 2계층 장비 : Switch, Bridge
>
> 패리티비트, 블록합검사, CRC(순환잉여검사) 추가

 

**1 계층 : Physical Layer(물리 계층)**

> 네트워크 통신을 위한 물리적인 표준을 정의하는 계층
>
> 두 컴퓨터 간의 전기적, 기계적, 절차적인 연결을 정의하는 계층
>
> 케이블 종류, 데이터 송수신 속도, 신호의 전기 전압 등
>
> 1 계층 장비 : Hub, Repeater





> 애플리케이션
>
> 프레젠테이션 : 압축, 암호화, 복호화 수행
>
> 세션 : 세션관리
>
> 전송* : 연결지향 데이터 스트림 지원, 신뢰성 있는 데이터 전송, 흐름제어, 분할/조립(단위 : segment), TCP/UDP, 비트에러감지 `체크섬`
>
> 네트워크 : 패킷의 경로 설정(스위칭),  ICMP/ ARP / RARP/ IP
>
> 데이터링크 : 
>
> 물리 : 



> TCP : 신뢰성있는 데이터전송, 연결제어, 흐름제어, 혼잡제어
>
> UDP : 데이터를 broadcast 해서 그냥 막 보낸다. 즉 연결하지않고 일방적으로 통신하는 구조, 신뢰성이 없음, TV 송출, 실시간 스트리밍



> 체크섬 : 중복섬사의 한 형태, 송신된 자료의 무결성을 보호하는 단순한 방법.
>
> 통신의 CRC(순환중복검사) 와는 다른형태.
>
> *계산방법
>
> 0x25, 0x62, 0x3F, 0x52(16진수)의 데이터가 있을 때, 모두 더한다.
>
> 0x118(16)를 2진수로 변환시킨다. 16진수 => 2진수 변환방법은 1,1,8을 각각 2진수로 변환시키면 된다.
>
> 즉, `0001 0001 1000` 이 된다.
>
> 캐리니블, 즉 최상위 니블을 버리면 `0001 1000`, 2의 보수를 취해주면 ( 뒤집고 1추가 )
>
> `1110 1000` 가 된다. 16진수로 계산하면 `0xE8` 체크섬 완성이다.
>
> 체크섬 테스트
>
> 0x118 + 0xE8(체크섬) 을 계산하면 0x200, 2진수로 변환시키면 `0010 0000 0000`
>
> 캐리니블을 버리면 `0000 0000` 이다.
>
> 즉, 오류가 없다.



> ARP : IP주소로 Mac주소를 찾는 프로토콜
>
> RARP : Mac주소로 IP주소를 찾는 프로토콜



> 3-way handshaking : 신뢰성있는 통신을 하기 위해서는 전송계층에서 순서번호를 사용한다.
>
> TCP 프로토콜에서 통신이 이뤄지기 위해서는 먼저 서로 연결되어야 하고, 서로의 임의의 시작순서번호를 알려줘야 한다.
>
> 이 과정을 3-way handshaking이라고 한다.
>
> Client	---->	Server  : SYN(seq number : X)  전송
>
> Client	<----	Server  : ACK(seq number : X+1) + SYN(seq number : Y) 전송
>
> Client	---->	Server : ACK(seq number : Y+1) 전송





## IPv4, IPv6

우리가 익숙한 192,168.0.1과 같은 주소는 IPv4

2^32, 즉 40억개, 현재는 주소고갈로 IPv6로 대체되고 있다.

IPv4는 32비트 ( 8bit x 4 )

IPv6는 128비트 ( 16bit x 8 )

## Subnet Mask

네트워크 영역과 호스트 영역을 나누기 위해서 사용하는 녀석.

네트워크 자원을 효율적으로 분배하기 위해 사용한다.

서브넷 마스크는 0과 1로 표현한다.

예를들어, `192.168.2.1/24 `가 주어졌다면, 

서브넷 마스크는` 1111 1111 . 1111 1111 . 1111 1111 . 0000 0000 ( 255.255.255.0 )`

서브넷 네트워크는 네트워크 부인 ` 192.168.2.0`

즉 1이 네트워크 영역, 0이 호스트 영역.

같은 네트워크 영역에서 통신이 가능하며, 네트워크 영역이 다르더라도 라우터, 게이트웨이 등을 통해 통신할 수 있다.

> C 클래스 : 255.255.255.0
>
> B 클래스 : 255.255.0.0
>
> A 클래스 : 255.0.0.0



예시 )

201.222.5.0/28

11001001 11011110 00000101 00000000 = 201.222.5.0 ( IP 주소 )

11111111 11111111 11111111 11111000 = 255.255.255.248 ( 서브넷마스크 )

11111111 11111111 11111111 ( 기본 C 클래스가 가질 수 있는 네트워크 영역 )

11111 ( 사용자가 지정한 네트워크 영역 )

000 ( 사용자가 지정한 호스트 영역 )

서브넷 네트워크 갯수는 00000~11111 (2^5) 까지 쪼갤 수 있다. 즉 32개.

호스트 IP 갯수는 000 ~ 111 ( 2^ 3 ) 이지만 네트워크 주소와 브로드캐스트 주소를 써야하기 때문에 -2해줘야 한다. 즉 8-2, 6개



## Nagle Algorithm

> 네트워크상의 패킷 수를 줄이기 위해 제안된 알고리즘
>
> ACK를 수신해야만 다음 전송을 진행하는 알고리즘.
>
> **Nagle 알고리즘을 적용하지 않았을 때,**
>
> ACK 수신에 상관없이 자신의 전송 버퍼 데이터가 있으면 상대방 호스트에게 전송한다.

N A G L E 를 보낸다고 했을때 3-way를 여러번 하는데 이게 아니라 N을 보내고 ACK를 받으면 AGLE를 한번에 보낸다는 의미다.



> **Nagle 알고리즘 사용방법**
>
> level : IPPROTO_TCP
>
> option : TCP_NODALAY
>
> > TRUE : Nagle OFF
> >
> > FALSE : Nagle ON
>
> server_sock = socket(PF_INET SOCK_STREAM, 0);
>
> option = TRUE; // #define TRUE 1;
>
> TCP에서 데이터 전송은 Nagle 알고리즘에 의해 처리된다. Nagle 알고리즘에 의하여 전송할 데이터의 누적된 크기가 일정 크기 이상이 되거나 전송을 시도한 이후에 일정 시간이 경과된 뒤에야 데이터가 전송된다. 또한, 수신측에서도 데이터 도착을 확인하는 패킷(ACK)을 전송하는 것을 특정 시간동안 지연시켜서 이 패킷과 같이 전송할 데이터를 기다리게 된다. 패킷을 작은 데이터로 여러번 전송하는 것은 비효율적일 뿐만 아니라 에러 체크나 전송확인(ACK)때문에 부하가 증가하는 원인이다.