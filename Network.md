> # Network
>
> ## OSI 7 Layer
>
> - 7 계층 : Application Layer(응용 계층)
>
>   - 사용자 인터페이스의 역할을 담당하는 계층 ( 즉, 사용자가 이용하는 네트워크 응용프로그램)
>
>   - 사용자와 가장 가까운 프로토콜을 정의
>
>   - EX) HTTP(80), FTP(20,21), Telnet(23), SMTP(25), DNS(53), TFTP(69) 등
>
>     
>
> - 6 계층 : Presentation Layer(표현 계층)
>   - 전송하는 데이터의 Format(구성 방식)을 결정하는 계층
>   - 다양한 데이터 Format을 일관되게 상호 변환, 압축 및 암호화, 복호화 기능을 수행
>   - EX) ASCII, EBCDIC, CIF, JPEG, AVI, MPEG 등
>
>  
>
> - 5 계층 : Session Layer(세션 계층)
>   - 네트워크 상에서 통신을 할 경우 양쪽 host간 최초 연결이 되게 하고 통신 중 연결이 지속되도록 시켜주는 역할을 하는 계층.통신을 하는 두 host사이에 세션을 열고, 닫고, 관리하는 기능을 담당.
>   - 데이터 동기화와 네트워크 오류 이벤트 검사, 오류가 발생한 지점 이후의 데이터만 재전송 보장. 
>   - 데이터 송수신 방식(Duplex), 반 이중 방식(Half Duplex), 전 이중 방식(Full Duplex)의 통신과 함께, 체크 포인팅과 유휴, 종료, 다시 시작 과정을 수행
>
> 
>
> - 4 계층 : Transport Layer(전송 계층)
>   - 4계층의 단위 : Segment
>   - 에러제어, 흐름제어, 데이터 분할/조립, 체크섬 검사*
>   - 전송 방식을 결정 ex) 포트번호나 TCP/UDP 등
>   - 4계층 프로토콜 : TCP, UDP
>   - TCP - 신뢰성, 연결지향성 프로토콜, Connection-ful(연결을 유지하며 전송하는 방식
>   - UDP - 비 신뢰성, 비 연결지향성 프로토콜, Connection-less(연결을 유지하지 않고 전송하는 방식, data손실을 신경쓰지 않음)
>
>  
>
> - 3 계층 : Network Layer(네트워크 계층)
>
>   - Logical address(IP, IPX)를 담당하고, 패킷의 이동경로를 결정하는 계층
>
>   - 3계층의 단위 : Packet
>
>   - 경로선택, 라우팅, 논리적인주소(IP)를 정의하는 계층
>
>   - Routing Protocol을 이용하여 최적경로를 선택
>
>   - IP, ICMP, ARP, RARP 등
>
>   - 3계층 장비 : Router
>
>     
>
> - 2 계층 : Data Link Layer(데이터링크 계층)
>   - 물리적 계층을 통한 데이터 전송에 신뢰성을 제공
>   - 이러한 서비스를 위해 물리적 주소(MAC) 지정, 네트워크 토폴로지, 오류통지, 프레임의 순차적 전송, 흐름제어 등의 기능을 가짐.
>   - 직접 연결되어 있지 않은 네트워크에 대해서는 상위 계층에서 오류 제어를 담당.
>   - 두가지 하위 게층이 존재
>   - 오류검출: 패리티검사, 블록합 검사, CRC
>   - 2계층 장비 : Switch, Bridge
>
>  
>
> - 1 계층 : Physical Layer(물리 계층)
>   - 네트워크 통신을 위한 물리적인 표준을 정의하는 계층
>   - 두 컴퓨터 간의 전기적, 기계적, 절차적인 연결을 정의하는 계층
>   - 케이블 종류, 데이터 송수신 속도, 신호의 전기 전압 등
>   - 1 계층 장비 : Hub, Repeater
>
> <br>
>
> ## TCP / UDP 
>
> > TCP : 신뢰성있는 데이터전송, 연결제어, 흐름제어, 혼잡제어
> >
> > UDP : 데이터를 broadcast 해서 그냥 막 보낸다. 즉 연결하지않고 일방적으로 통신하는 구조, 신뢰성이 없음, TV 송출, 실시간 스트리밍
>
> <br>
>
> ## 체크섬
>
> > 중복섬사의 한 형태, 송신된 자료의 무결성을 보호하는 단순한 방법.
> >
> > 통신의 CRC(순환중복검사) 와는 다른형태.
> >
> > > 계산방법
> > >
> > > 0x25, 0x62, 0x3F, 0x52(16진수)의 데이터가 있을 때, 모두 더한다.
> > >
> > > 0x118(16)를 2진수로 변환시킨다. 16진수 => 2진수 변환방법은 1,1,8을 각각 2진수로 변환시키면 된다.
> > >
> > > 즉, `0001 0001 1000` 이 된다.
> > >
> > > 캐리니블, 즉 최상위 니블을 버리면 `0001 1000`, 2의 보수를 취해주면 ( 뒤집고 1추가 )
> > >
> > > `1110 1000` 가 된다. 16진수로 계산하면 `0xE8` 체크섬 완성이다.
> > >
> > > 체크섬 테스트
> > >
> > > 0x118 + 0xE8(체크섬) 을 계산하면 0x200, 2진수로 변환시키면 `0010 0000 0000`
> > >
> > > 캐리니블을 버리면 `0000 0000` 이다.
> > >
> > > 즉, 오류가 없다.
>
> <br>
>
> ## 패리티 검사(Parity Check)
>
> > 패리티 비트(parity bit)는 정보의 전달 과정에서 오류가 생겼는지를 검사하기 위해 추가된 비트다.
> >
> > 전송하고자 하는 데이터 끝에 1비트를 더하여 전송하는 방법으로 2가지의 패리티 비트(홀수, 짝수)가 있다.
> >
> > - 홀수(Odd) 패리티 : 전송하고자 하는 데이터를 홀수로 만들 수 있도록 패리티 비트를 설정한다.
> >   - 예를들어, `1 0 0 0 1 0 1 0` 의 데이터를 송신할 경우 1이 홀수(3)개 있으므로 패리티 비트 자리에 0이 붙는다.
> > - 짝수(Even) 패리티 : 홀수 패리티와 반대로 데이터를 포함해 짝수를 만들어낼 수 있도록 함.
> >   - 위의 예시에서는 패리티 비트 자리에 1이 붙는다.
>
> <br>
>
> ## 블록 합 검사(Block Sum Check)
>
> > 패리티 검사를 수직, 수평 2차원적적으로 이중검사하는 방법으로, 한 데이터에서 짝수개의 오류가 발생하더라도 오류검출이 가능하다.
> >
> > 단, 패리티방식에 비해 많은 오버헤드가 발생한다.
>
> <br>
>
> ## 순환 중복 검사 (CRC: Cyclic Redundancy Checking)
>
> > CRC는 다항식을 통해서 값을 구한다.
> >
> > 생성 다항식은 CRC16, CRC32 등 지정된 다항식으로 계산한다.
> >
> > 송수신 측은 동일한 다항식을 결정하고, 데이터 뒤에 n-1비트만큼 0을 추가한 후 다항식으로 XOR 처리한다.
> >
> > 계산 후 나머지 값을 데이터 뒤에 추가하고, 수신측은 받은 정보를 다항식으로 다시 XOR 처리한다.
> >
> > 나머지가 0이면 정상, 아니면 오류로 판단.
> >
> > > 예를들어,
> > >
> > > 다항식 : 1011
> > >
> > > 데이터 : 110101
> > >
> > > 다항식이 4개이므로 데이터 뒤에 0을 세개 추가한다.
> > >
> > > 나머지가 나올때 까지 XOR처리하면 111이 남는다.
> > >
> > > 데이터에 111을 추가하여 송신 ( 110101111 )
> > >
> > > 수신측에서 다시 다항식으로 나누면 나머지값은 0이 된다.
>
> <br>
>
> ## ARP / RARP
>
> > ARP : IP주소로 Mac주소를 찾는 프로토콜
> >
> > RARP : Mac주소로 IP주소를 찾는 프로토콜
>
> <br>
>
> ## 3-Way Handshaking
>
> > 신뢰성있는 통신을 하기 위해서는 전송계층에서 순서번호를 사용한다.
> >
> > TCP 프로토콜에서 통신이 이뤄지기 위해서는 먼저 서로 연결되어야 하고, 서로의 임의의 시작순서번호를 알려줘야 한다.
> >
> > 이 과정을 3-way handshaking이라고 한다.
> >
> > Client	---->	Server  : SYN(seq number : X)  전송
> >
> > Client	<----	Server  : ACK(seq number : X+1) + SYN(seq number : Y) 전송
> >
> > Client	---->	Server : ACK(seq number : Y+1) 전송
>
> <br>
>
> 
>
> ## IPv4, IPv6
>
> 우리가 익숙한 192,168.0.1과 같은 주소는 IPv4
>
> 2^32, 즉 40억개, 현재는 주소고갈로 IPv6로 대체되고 있다.
>
> IPv4는 32비트 ( 8bit x 4 )
>
> IPv6는 128비트 ( 16bit x 8 )
>
> 
>
> <br>
>
> ## Subnet Mask
>
> 네트워크 영역과 호스트 영역을 나누기 위해서 사용하는 녀석.
>
> 네트워크 자원을 효율적으로 분배하기 위해 사용한다.
>
> 서브넷 마스크는 0과 1로 표현한다.
>
> 예를들어, `192.168.2.1/24 `가 주어졌다면, 
>
> 서브넷 마스크는` 1111 1111 . 1111 1111 . 1111 1111 . 0000 0000 ( 255.255.255.0 )`
>
> 서브넷 네트워크는 네트워크 부인 ` 192.168.2.0`
>
> 즉 1이 네트워크 영역, 0이 호스트 영역.
>
> 같은 네트워크 영역에서 통신이 가능하며, 네트워크 영역이 다르더라도 라우터, 게이트웨이 등을 통해 통신할 수 있다.
>
> > C 클래스 : 255.255.255.0
> >
> > B 클래스 : 255.255.0.0
> >
> > A 클래스 : 255.0.0.0
>
> 
>
> ### 예시 )
>
> 201.222.5.0/29
>
> 11001001 11011110 00000101 00000000 = 201.222.5.0 ( IP 주소 )
>
> 11111111 11111111 11111111 11111000 = 255.255.255.248 ( 서브넷마스크 )
>
> 11001001 11011110 00000101 00000000 = 201.222.5.0 ( 네트워크 주소 )
>
> 11001001 11011110 00000101 00000111 = 201.222.5.8 ( 브로드캐스트 주소 )
>
> 
>
> 11111111 11111111 11111111 ( 기본 C 클래스가 가질 수 있는 네트워크 영역 )
>
> 11111 ( 사용자가 지정한 네트워크 영역 )
>
> 000 ( 사용자가 지정한 호스트 영역 )
>
> 서브넷 네트워크 갯수는 00000~11111 (2^5) 까지 쪼갤 수 있다. 즉 32개.
>
> 호스트 IP 갯수는 000 ~ 111 ( 2^ 3 ) 이지만 네트워크 주소와 브로드캐스트 주소를 써야하기 때문에 -2해줘야 한다. 즉 8-2, 6개
>
> 
>
> ## Nagle Algorithm
>
> > 네트워크상의 패킷 수를 줄이기 위해 제안된 알고리즘
> >
> > ACK를 수신해야만 다음 전송을 진행하는 알고리즘.
> >
> > **Nagle 알고리즘을 적용하지 않았을 때,**
> >
> > ACK 수신에 상관없이 자신의 전송 버퍼 데이터가 있으면 상대방 호스트에게 전송한다.
>
> 
>
> > **Nagle 알고리즘 사용방법**
> >
> > level : IPPROTO_TCP
> >
> > option : TCP_NODALAY
> >
> > > TRUE : Nagle OFF
> > >
> > > FALSE : Nagle ON
> >
> > server_sock = socket(PF_INET SOCK_STREAM, 0);
> >
> > option = TRUE; // #define TRUE 1;
> >
> > TCP에서 데이터 전송은 Nagle 알고리즘에 의해 처리된다. Nagle 알고리즘에 의하여 전송할 데이터의 누적된 크기가 일정 크기 이상이 되거나 전송을 시도한 이후에 일정 시간이 경과된 뒤에야 데이터가 전송된다. 또한, 수신측에서도 데이터 도착을 확인하는 패킷(ACK)을 전송ㅇ하는 것을 특정 시간동안 지연시켜서 이 패킷과 같이 전송할 데이터를 기다리게 된다. 패킷을 작은 데이터로 여러번 전송하는 것은 비효율적일 뿐만 아니라 에러 체크나 전송확인(ACK)때문에 부하가 증가하는 원인이다.